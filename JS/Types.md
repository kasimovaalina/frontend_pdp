# Типы данных
## Методы примитивов
Примитивные типы данных:
1. `string`
2. `number`
3. `boolean`
4. `symbol`
5. `null`
6. `undefined`
7. `bigint`

Почти каждый примитивный тип (кроме undefined и null) данных имеет "объект-оболочку", с помощью которых появляется возможность обратится к методам.

## Методы массивов
### Добавление и удаление
- `arr.push(...items)` – добавляет элементы в конец,
- `arr.pop()` – извлекает элемент из конца,
- `arr.shift()` – извлекает элемент из начала,
- `arr.unshift(...items)` – добавляет элементы в начало.
### Метод `splice`
Универсальный метод для работы с массивами
```
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
```
Пояснение: массив arr изменяется начиная с индекса start: удаляет deleteCount элементов и затем вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.
### Метод `slice`
```
arr.slice([start], [end])
```
Возвращает новый массив, в который копирует все элементы с индекса start до end
### Метод `concat`
Cоздаёт новый массив, в который копирует _данные_ из других массивов и _дополнительные значения_.
### Метод перебора `forEach`
Позволяет запускать функцию для каждого элемента массива
### Методы поиска в массиве
- `indexOf`/`lastIndexOf`
`arr.indexOf(item, from)` ищет `item` начиная с индекса `from` и возвращает номер индекса, на котором был найден искомый элемент, в противном случае `-1`.
- `includes`
`arr.includes(item, from)` ищет `item` начиная с индекса `from` и возвращает `true`, если поиск успешен
Оба метода можно использовать без аргумента `from`, тогда по умолчанию будет значение 0.
- `find`
Удобен для поиска в массиве объектов. Если элемент соотвествует условию и возвращает `true`, поиск прекращается и возвращается `item`.
- `findIndex`/`findLastIndex`
Аналогичный синтаксис, но возвращает индекс.
- `filter`
Аналогичен `find`, но возвращает массив элементов, которые соотвествуют условию.
### Методы преобразования массива
- `map`
Вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
- `sort`
Сортирует массив на месте, меняя в нём порядок элементов. Можно передать функцию-компоратор для корректного сравнения элемента.
**По умолчанию** элементы сортируются **как строки**.
Синтаксис функции-компоратор:
```
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}
```
- `reverse`
Vеняет порядок элементов в массиве на обратный.
- `split`
Разбивает строку на массив по заданному разделителю.
- `join`
Создаёт строку из элементов массива, вставляя разделитель между ними.
- `reduce`/`reduceRight`
Используются для вычисления единого значения на основе всего массива.
## Перебираемые (итерируемые) объекты
Обобщение массивов. Концепция, которая позволяет использовать любой объект в цикле `for..of`.
//TODO: дописать про итераторы
## `Map` и `Set`
`Map` – это коллекция ключ/значение, как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого типа.
>В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.
'Set' — коллекция для хранения уникальных значений без ключей. 
## `WeakMap` и `WeakSet`
### `WeakMap`
Если мы используем объект как ключ в `Map`, то до тех пор, пока существует `Map`, также будет существовать и этот объект. Он занимает место в памяти и не может быть удалён сборщиком мусора.
`WeakMap` – принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.
Еще отличия:
1. Ключи в `WeakMap` должны быть объектами, а не примитивными значениями.
2. `WeakMap` не поддерживает перебор и методы `keys()`, `values()`, `entries()`, так что нет способа взять все ключи или значения из неё.
### `WeakSet`
1. Можем добавлять в `WeakSet` только объекты (не примитивные значения).
2. Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
3. Поддерживает `add`, `has` и `delete`, но не `size`, `keys()` и не является перебираемой.
## `Object.keys`, `values`, `entries`
### `keys`
Возвращает массив ключей.
### `values`
Возвращает массив значений.
### `entries`
Возвращает массив пар `[ключ, значение]`.
## Деструктурирующее присваивание
`Деструктурирующее присваивание` – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.

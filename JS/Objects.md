# Объекты
## Копирование объектов и ссылки
Объекты хранятся и копируются по ссылке, в то время как примитивные значения всегда копируются как целое значение.
### Сравнениее по ссылке
Два объекта равны только в том случае, если это один и тот же объект:
```
let a = {};
let b = a; // копирование по ссылке

alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
```
Два независимых объекта не равны, даже если выглядят одинаково:
```
let a = {};
let b = {}; // два независимых объекта

alert( a == b ); // false
```
### Клонирование и объединения, `Object.assign`
1. Перебор объекта как способ кланирования
```
let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект

// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

alert( user.name ); // все ещё John в первоначальном объекте
```
2. `Object.assign`
```Object.assign(dest, [src1, src2, src3...])```
  - `dest` — целевой объект.
  - остальные аргументы `src1, ..., srcN` (может быть столько, сколько необходимо) являются исходными объектами
  - метод копирует свойства всех исходных объектов `src1, ..., srcN` в целевой объект `dest`. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
  - возвращает объект `dest`
  - (!) если скопированное имя свойства уже существует, оно будет перезаписано
3. Вложенное (глубокое) клонирование
  - случай, когда свойства являются ссылками на другие объекты, а не примитивы.
  - можно использовать рекурсию
  - или реализацию _.cloneDeep(value) из библиотеки `lodash`
  - стандартный метод strucutredClone (поддерживаются только современными браузерами)
## Методы объекта, `this`
## Конструктор, оператор `new`

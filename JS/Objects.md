# Объекты
## Копирование объектов и ссылки
Объекты хранятся и копируются по ссылке, в то время как примитивные значения всегда копируются как целое значение.
### Сравнение по ссылке
Два объекта равны только в том случае, если это один и тот же объект:
```
let a = {};
let b = a; // копирование по ссылке

alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
```
Два независимых объекта не равны, даже если выглядят одинаково:
```
let a = {};
let b = {}; // два независимых объекта

alert( a == b ); // false
```
### Клонирование и объединения, `Object.assign`
1. Перебор объекта как способ кланирования
```
let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект

// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

alert( user.name ); // все ещё John в первоначальном объекте
```
2. `Object.assign`
```Object.assign(dest, [src1, src2, src3...])```
  - `dest` — целевой объект.
  - остальные аргументы `src1, ..., srcN` (может быть столько, сколько необходимо) являются исходными объектами
  - метод копирует свойства всех исходных объектов `src1, ..., srcN` в целевой объект `dest`. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
  - возвращает объект `dest`
  - (!) если скопированное имя свойства уже существует, оно будет перезаписано
3. Вложенное (глубокое) клонирование
  - случай, когда свойства являются ссылками на другие объекты, а не примитивы.
  - можно использовать рекурсию
  - или реализацию _.cloneDeep(value) из библиотеки `lodash`
  - стандартный метод strucutredClone (поддерживаются только современными браузерами)
## Методы объекта, `this`
Используется для доступа к информации внутри объекта. Значение `this` - это объект "перед точкой", который используется для вызова метода/свойства.
> `this` не является фиксированным! Значение this вычисляется во время выполнения кода, в зависимости от контекста.

> У стрелочных функций нет `this`! Если мы ссылаемся на `this` внутри такой функции, то оно берётся из внешней «нормальной» функции.
## Конструктор, оператор `new`
### Функция-конструктор
1. Имя должно начинаться с большой буквы
2. Должна выполняться только с помощью оператора "new"
Пример:
```
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
```
Когда функция вызывается как `new User(...)`, происходит следующее:

1. Создаётся новый пустой объект, и он присваивается `this`.
2. Выполняется тело функции. Обычно оно модифицирует `this`, добавляя туда новые свойства.
3. Возвращается значение `this`.

Можно представить код вот так:
```
function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}
```
> Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.
> В случае обычного вызова функции new.target будет undefined. Если же она была вызвана при помощи new, new.target будет равен самой функции.

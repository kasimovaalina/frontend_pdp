# Алгоритм согласования (reconciliation)
React реализует эвристический алгоритм O(n), который основывается на двух утверждениях:
1. Два элемента с разными типами произведут разные деревья.
2. Разработчик может указать какие дочерние элементы останутся стабильными между рендерами с помощью пропа key.

React сравнивает деревья начиная с их корневых элементов и направляется вниз. Сравниваются типы (теги) корневых элементов.
Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. Трансформация из <a> в <img>, или из <Article> в <Comment>, или из <Button> в <div> приведут к полному перестроению вложенных элементов.

При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают componentWillUnmount(). При построении нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают UNSAFE_componentWillMount(), а затем componentDidMount(). Любое состояние, связанное со старым деревом, теряется.

Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится. Например, это произойдёт при таком сравнении:
```
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
```

При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты. Например:
```
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```
Сравнивая эти элементы, React знает, что нужно модифицировать только className у DOM-узла.
Обновляя style, React также знает, что нужно обновлять только изменившиеся свойства.

Когда у дочерних элементов есть ключи, React воспользуется ими, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Например, если добавить key к неэффективному примеру выше, преобразование дерева станет эффективнее:
```
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```

React полагается на эвристику, следовательно, если утверждения, на которых она основана, не соблюдены, то пострадает производительность.

Алгоритм не будет пытаться сравнивать поддеревья компонентов разных типов. Если вы заметите за собой, что пытаетесь использовать компоненты разных типов с очень схожим выводом, то, вероятно, стоит их сделать компонентами одного типа. На практике мы не выявили с этим проблем.
Ключи должны быть стабильными, предсказуемыми и уникальными. Нестабильные ключи (например, произведённые с помощью Math.random()) вызовут необязательное пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних компонентов.

# useEffect
`useEffect` — это хук, который можно использовать для замены некоторых методов жизненного цикла классового компонента.
`useEffect` используется с функциональными компонентами в следующих случаях:
- при визуализации компонента (метод componentDidMount в классовом компоненте);
- при обновлении компонента (метод componentDidUpdated в классовом компоненте);
- при удалении компонента из DOM (метод componentWillUnmount в классовом компоненте).
`useEffect` принимает два параметра. Первый аргумент — это функция обратного вызова, для которой мы будем выполнять побочные эффекты; другой – массив зависимостей. Второй аргумент является необязательным.
Если мы **не** передадим **второй** аргумент, побочный эффект в функции обратного вызова будет запускаться **снова при каждой визуализации компонента**.
```
function MyComponent() {
  useEffect(() => {
    // The side effect will run after every render
  })
}
```
Если мы передаем второй аргумент в виде **пустого массива**, побочный эффект в функции обратного вызова сработает только **один** раз при первой визуализации компонента.
```
function MyComponent() {
  useEffect(() => {
    // This side effect will only run once, after the first render
  }, [])
}
```
Если мы передаем свойства или значения состояния во втором аргументе, побочный эффект в функции обратного вызова будет выполняться только при изменении значений свойств или переменной состояния.
```
import { useEffect, useState } from 'react'
function MyComponent({ prop }) {
   const [state, setState] = useState('')
   useEffect(() => {
      // the side effect will only run when the props or state changed
   }, [prop, state])
}
```
## Функция очистки useEffect
```
function MyComponent() {
  useEffect(() => {
    // this side effect will run after every render
    return () => {
      // this side effect will run before the component is unmounted
    }
  })
}
```
# useEffectLayout
Хук `useLayoutEffect` по своим параметрам (сигнатуре) полностью идентичен хуку `useEffect`. Главное же отличие заключается в том, что `useLayoutEffect` вызывается синхронно, после всех изменений в DOM. Также сами разработчики React рекомендуют использовать `useLayoutEffect` только в случае острой необходимости, чтобы вдруг не возникло проблем с правильным рендерингом компонентов. Хук `useLayoutEffect` можно использовать в случаях, когда необходимо произвести какие-то вычисления либо замеры в реальном DOM или провести синхронно мутацию (изменения).

# Вывод
```
  useEffect(() => {
    console.log("Без аргументов, работаем КАЖДЫЙ раз, когда рендеримся")
  })

  useEffect(() => {
    console.log("С пустым массивом рендеримся ОДИН раз при первой визуализации компонента")
  }, [])

  useEffect(() => {
    console.log("Это выполняется каждый раз")
    return () => { console.log("А вот это перед анмаунтом") }
  })

  /* useEffect не блокирует ОТРИСОВКУ браузера, выполняется каждый после рендеринга И отрисовки*/
  /* useLayoutEffect БЛОКИРУЕТ ОТРИСОВКУ браузера, выполняется каждый после рендеринга и ДО отрисовки*/
```
